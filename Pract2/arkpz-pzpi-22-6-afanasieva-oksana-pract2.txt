Міністерство освіти і науки України
Харківський національний  університет радіоелектроніки


Кафедра «Програмної інженерії»


ЗВІТ
з практичної роботи №2
з дисципліни «Аналіз та рефакторинг коду»
на тему: «Методи рефакторингу коду програмного забезпечення»


Виконала:	              Перевірив:
ст. гр. ПЗПІ-22-6	      ст. викладач
Афанасьєва О.М.	        Сокорчук І. П.





Харків 2024
2 МЕТОДИ РЕФАКТОРИНГУ КОДУ ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ
2.1	Мета роботи:
Ознайомитися з різними методами рефакторингу програмного коду та продемонструвати їх використання на реальних прикладах.
2.2 Хід роботи:
Метод Replace Error Code with Exception
Replace Error Code with Exception — це метод, що передбачає заміну числових або стрічкових кодів помилок на використання механізму винятків. Цей підхід зменшує кількість умовного коду та робить програму більш структурованою.
Механізм винятків звільняє код від великої кількості умов для перевірки різних кодів помилок. Обробники винятків чітко розмежовують нормальний і ненормальний потоки виконання.
Класи винятків можуть реалізовувати власні методи, що містять частину функціональності обробки помилок, наприклад, для надсилання повідомлень про помилки.
На відміну від кодів помилок, винятки можуть використовуватись у конструкторах, оскільки конструктор повинен повертати тільки новий об’єкт.
1 //До рефакторингу
2 public class Account
3 {
4     public int Withdraw(decimal amount)
5     {
6         if (amount > Balance)
7         {
8             return -1;
9         }
10 
11         Balance -= amount;
12         return 0;
13     }
14 
15     public decimal Balance { get; private set; }
16 }
17 
18 public class Program
19 {
20     public static void Main()
21     {
22         Account account = new Account();
23         int result = account.Withdraw(100);
24 
25         if (result == Account.ErrorCodeInsufficientFunds)
26         {
27             Console.WriteLine("Insufficient funds.");
28         }
29     }
30 }
Використання числових кодів помилок робить код менш зрозумілим та більш вразливим до помилок.
1 //Після рефакторингу
2 public class Account
3 {
4     public void Withdraw(decimal amount)
5     {
6         if (amount > Balance)
7         {
8             throw new InvalidOperationException("Insufficient funds.");
9         }
10 
11         Balance -= amount;
12     }
13 
14     public decimal Balance { get; private set; }
15 }
16 
17 public class Program
18 {
19     public static void Main()
20     {
21         try
22         {
23             Account account = new Account();
24             account.Withdraw(100);
25         }
26         catch (InvalidOperationException ex)
27         {
28             Console.WriteLine(ex.Message);
29         }
30     }
31 }
Після використання рефакторингу логіка помилок стає більш очевидною завдяки явним виняткам, винятки дозволяють централізовано обробляти помилки через механізм try-catch та покращено читабельність і масштабованість коду.
Метод Replace Exception with Test
Replace Exception with Test — це метод, що передбачає заміну винятків на попередню перевірку, коли проблема передбачувана. Це підвищує продуктивність програми та спрощує її логіку.
Винятки слід використовувати для обробки непередбачуваної поведінки, пов’язаної з помилкою, а не для заміни перевірки. Якщо винятку можна уникнути, просто перевіривши умову перед виконанням, це краще зробити. Винятки повинні бути зарезервовані для реальних помилок.
1 //До рефакторингу
2 public class Calculator
3 {
4     public int Divide(int numerator, int denominator)
5     {
6         try
7         {
8             return numerator / denominator;
9         }
10         catch (DivideByZeroException)
11         {
12             Console.WriteLine("Cannot divide by zero.");
13             return 0;
14         }
15     }
16 }
17 
18 public class Program
19 {
20     public static void Main()
21     {
22         Calculator calculator = new Calculator();
23         int result = calculator.Divide(10, 0);
24         Console.WriteLine($"Result: {result}");
25     }
26 }
Використання винятків для передбачуваних ситуацій, як наприклад ділення на нуль, є неефективним. Логіка стає заплутаною через використання винятків для стандартної поведінки.
1 //Після рефакторингу
2 public class Calculator
3 {
4     public int Divide(int numerator, int denominator)
5     {
6         if (denominator == 0)
7         {
8             Console.WriteLine("Cannot divide by zero.");
9             return 0;
10         }
11 
12         return numerator / denominator;
13     }
14 }
15 
16 public class Program
17 {
18     public static void Main()
19     {
20         Calculator calculator = new Calculator();
21         int result = calculator.Divide(10, 0);
22         Console.WriteLine($"Result: {result}");
23     }
24 }
Після використання рефакторингу зменшено використання винятків, що покращує продуктивність програми. Уникнення непотрібних винятків полегшує налагодження та підтримку. Попередня перевірка стану дозволяє уникнути виклику винятків, зберігаючи продуктивність.
Метод Remove Middle Man
Remove Middle Man — це метод, який передбачає усунення зайвих "посередників" між клієнтським кодом і функціональністю, яку він використовує. Це спрощує доступ до потрібних методів або даних і зменшує складність програми.
Цей метод підходить у випадках, коли клас посередника не додає жодної нової логіки чи функціональності, а лише делегує виклики іншому класу. Видалення такого класу дозволяє клієнтському коду безпосередньо взаємодіяти з необхідним функціоналом, спрощуючи структуру програми та зменшуючи кількість абстракцій.
1 //До рефакторингу
2 public class Manager
3 {
4     private Worker worker = new Worker();
5 
6     public string GetWorkerName()
7     {
8         return worker.Name;
9     }
10 }
11 
12 public class Worker
13 {
14     public string Name { get; set; } = "Harry";
15 }
16 
17 public class Program
18 {
19     public static void Main()
20     {
21         Manager manager = new Manager();
22         Console.WriteLine(manager.GetWorkerName());
23     }
24 }
Клас Manager не додає жодної нової логіки, лише делегує виклики до Worker.
Прибираємо зайвий посередницький клас Manager, дозволивши коду працювати безпосередньо з Worker.
1 //Після рефакторингу
2 public class Worker
3 {
4     public string Name { get; set; } = "Harry";
5 }
6 
7 public class Program
8 {
9     public static void Main()
10     {
11         Worker worker = new Worker();
12         Console.WriteLine(worker.Name);
13     }
14 }
Після рефакторингу було спрощено структуру програми, зменшено кількість класів, що надає прямий доступ до потрібних методів без зайвого делегування та покращує розуміння та підтримку програми завдяки усуненню зайвих шарів абстракції.
Список використаних джерел:
	Мартін Р. Чистий код: створення і рефакторинг за допомогою AGILE. – ФАБУЛА, 2019. – 416 с.
	Martin Fowler. Refactoring. Improving the Design of Existing Code – Addison-Wesley Professional, 1999. – 464 p.
	Refactoring Guru. Remove Middle Man. URL: https://refactoring.guru/remove-middle-man
2.3 Висновок:
Рефакторинг є невіддільною частиною процесу розробки програмного забезпечення, що дозволяє підвищити якість коду, спростити його підтримку та полегшити розширення. У цій доповіді були розглянуті три методи рефакторингу. 
Кожен з цих методів вирішує конкретні проблеми у коді та робить його ефективнішим. Впровадження рефакторингу сприяє створенню програм, які легше читати, підтримувати та модифікувати.
2.4 Посилання:
Посилання на GitHub репозиторій:
https://github.com/NureAfanasievaOksana/arkpz-pzpi-22-6-afanasieva-oksana/tree/main/Pract2
Посилання на YouTube відео з виступом:


ДОДАТОК А
Слайди презентації

Рисунок А.1 – Титульний слайд
 
Рисунок А.2 – Зміст презентації
 
Рисунок А.3 – Вступ
 
Рисунок А.4 – Метод Replace Error Code with Exception
 
Рисунок А.5 – Приклад коду до рефакторингу
 
Рисунок А.6 – Приклад коду після рефакторингу
 
Рисунок А.7 – Метод Replace Exception with Test
 
Рисунок А.8 – Приклад коду до рефакторингу
 
Рисунок А.9 – Приклад коду після рефакторингу
 
Рисунок А.10 – Метод Remove Middle Man
 
Рисунок А.11 – Приклад коду до рефакторингу
 
Рисунок А.12 – Приклад коду після рефакторингу
 
Рисунок А.13 – Висновок

Рисунок А.14 – Список використаних джерел
 
Рисунок А.15 – Завершальний слайд
