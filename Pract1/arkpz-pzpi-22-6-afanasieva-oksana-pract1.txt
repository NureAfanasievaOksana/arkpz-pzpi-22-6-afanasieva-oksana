Міністерство освіти і науки України
Харківський національний  університет радіоелектроніки


Кафедра «Програмної інженерії»


ЗВІТ
з практичної роботи №1
з дисципліни «Аналіз та рефакторинг коду»
на тему: «Правила оформлення програмного коду»


Виконала:	Перевірив:
ст. гр. ПЗПІ-22-6	ст. викладач
Афанасьєва О.М.	Сокорчук І. П.





Харків 2024
1 Правила оформлення програмного коду
1.1 Мета роботи:
Ознайомитись з основними рекомендаціями щодо написання чистого, ефективного та підтримуваного коду для різних мов програмування, а також навчитися аналізувати та рефакторити код для покращення його якості.
1.2 Хід роботи:
1)	Було обрано мову програмування C++ для аналізу.
2)	Проведено ознайомлення з основними рекомендаціями для написання якісного та чистого коду на мові C++.
3)	Підготовлені приклади коду, що демонструють застосування наведених рекомендацій.
4)	Підготовлено презентацію, з аналізом основних рекомендацій для написання чистого коду на C++ та з наведеними прикладами коду, що демонструють використання цих рекомендацій.
Стильові рекомендації
Стиль кодування – це перший крок до створення чистого й зрозумілого коду.
Основними рекомендаціями є:
Використовувати відступи для позначення вкладеності, відступи мають бути 4 пробіли або табуляція. Неправильне вирівнювання ускладнює розуміння логіки програми.
Дотримуватися обмежень  на довжину рядка, зазвичай це не більше 80-120 символів.
Додавати порожні рядки між логічними блоками, оскільки це логічно розділяє код на секції, спрощуючи читання.
Використовувати фігурні дужки навіть для однорядкових конструкцій. Це знижує ризик помилок при розширенні коду. Якщо додати новий рядок без дужок, він може виконуватися поза блоком. Дужки варто розташовувати у стилі Allman, відкриваюча дужка знаходиться на наступному рядку, або K&R (Kernighan and Ritchie), відкриваюча дужка знаходиться на тому ж рядку, що й вираз.
Приклад:
1 //Поганий приклад
2 int main(){int x=10;if(x>0){cout<<"A positive number:"<<endl;}}
3 
4 //Гарний приклад
5 int main()
6 {
7     int x = 10;
8     if (x > 0)
9     {
10         cout << "A positive number: " << x << endl;
11    }
12    return 0;
13 }
Правила найменування змінних, функцій та класів
Назви змінних, функцій і класів – це один із найважливіших елементів зрозумілості коду. Осмислені назви дозволяють іншим програмістам легко розуміти призначення конкретного блоку коду.
Для змінних краще використовувати snake_case або camelCase.
Константи та макроси варто писати у верхньому регістрі з підкресленнями.
Для функцій потрібно використовувати camelCase. Також назва функції повинна описувати, що саме вона робить.
Класи найчастіше оформлюються у PascalCase. Їхні назви мають бути іменниками, які описують сутність.
Також варто уникати скорочень та незрозумілих абревіатур.
Приклад:
1 //Поганий приклад
2 class class1 {
3     int a = 25;
4 
5     bool f() {
6         return a >= 18;
7     }
8 };
9 
10 //Гарний приклад
11 class UserAccount {
12     int user_age = 25;
13 
14     bool isAdult() {
15         return user_age >= 18;
16     }
17 }; 
Структура коду
Добре структурована організація файлів полегшує навігацію у проєкті, допомагає швидко знаходити потрібні компоненти, зменшує час на пошук помилок і пришвидшує розробку.
 Основними принципами є:
Розділення оголошень і реалізацій. Поділ на заголовкові файли, що містять оголошення класів та функцій, та файли .cpp, що містять реалізацію цих класів та функцій.
Групування логіки за модулями. Розбиття коду на окремі модулі чи класи робить його більш структурованим, полегшує повторне використання коду, тестування та підтримку.
Використання коментарів. Коментарі допомагають швидше зрозуміти структуру коду та його призначення, особливо якщо код читають інші розробники.
Приклад:
1 //Гарний приклад
2 // rectangle.h
3 class Rectangle {
4 public:
5     Rectangle(int width, int height);
6     int calculateArea() const;
7 
8 private:
9     int width;
10     int height;
11 };
12 
13 // rectangle.cpp
14 #include "rectangle.h"
15 
16 Rectangle::Rectangle(int width, int height) : width(width), height(height) {}
17 
18 int Rectangle::calculateArea() const {
19     return width * height;
20 }
Коментарі
Тож коментарі відіграють важливу роль у структурі. Вони є важливим інструментом у програмуванні, але їх варто використовувати раціонально та з користю. Їх мета – не дублювати очевидний код, а пояснювати його логіку, особливо у випадках, де вона є складною або неочевидною.
Рекомендаціями щодо використання коментарів є:
Не пояснювати очевидний код. Не потрібно писати коментарі до простих обчислень чи зрозумілих операцій. Натомість варто пояснювати складні алгоритми, незвичайні рішення або обґрунтування вибору підходу.
Уникати надлишкових коментарів. Занадто велика кількість коментарів може створити шум і зробити код важчим для читання. Якщо код добре написаний, у більшості випадків він «сам себе коментує».
Використовувати TODO. TODO – Це спеціальні коментарі для позначення завдань, які потрібно виконати пізніше.
Приклад:
1 //Поганий приклад
2 class UserAccount { // Оголошення класу UserAccount
3     int user_age = 25; // Оголошення змінної user_age
4 
5     bool isAdult() { //Оголошення функції isAdult
6         return user_age >= 18; //Повернення результату
7     }
8 };
9 
10 //Гарний приклад
11 //TODO: Додати метод для оновлення віку користувача
12 class UserAccount {
13     int user_age = 25;
14 
15     bool isAdult() {
16         return user_age >= 18;
17     }
18 };
Принципи рефакторингу
Рефакторинг – це процес покращення існуючого коду без змін його функціональності. Добре рефакторизований код скорочує час, потрібний на внесення змін або виправлення помилок.  Основні принципи рефакторингу це:
DRY (Don’t Repeat Yourself): Уникайте дублювання коду, адже це ускладнює підтримку.
SRP (Single Responsibility Principle): Кожен клас або функція повинні виконувати лише одну задачу.
Застосовуйте зрозумілі імена: Замість коментарів краще використовувати описові імена.
Приклад:
1 //Поганий приклад
2 void processAndLogData(const vector<int>& data) {
3     for (int value : data) {
4         cout << "Processing: " << value << endl;
5         ofstream log("data.txt", ios_base::app);
6         log << "Processed: " << value << endl;
7     }
8 }
9 
10 //Гарний приклад
11 void processData(const vector<int>& data) {
12     for (int value : data) {
13         cout << "Processing: " << value << endl;
14         logData(value);
15     }
16 }
17 
18 void logData(int value) {
19     ofstream log("data.txt", ios_base::app);
20     log << "Processed: " << value << endl;
21 }
22 
23 //Поганий приклад
24 int addNumbers1(int a) {
25     return a + 1;
26 }
27 
28 int addNumbers2(int a) {
29     return a + 2;
30 }
31 
32 //Гарний приклад
33 int addNumbers(int a, int b) { 
34     return a + b; 
35 }
Оптимізація продуктивності
Оптимізація продуктивності є особливо важливою для великих проектів. Оптимізація забезпечує швидкість виконання та економію пам’яті. 
У C++ ключовими аспектами є:
Використання const: Додавання цього модифікатора дозволяє компілятору оптимізувати код і уникнути змін.
Передача параметрів за посиланням: Це зменшує витрати на копіювання.
Використання STL (Standard Template Library): Наприклад, стандартні алгоритми sort працюють швидше, ніж реалізація власноруч.
Приклад:
1 //Поганий приклад
2 void processVector(vector<int> data) {
3     bool swapped;
4     do {
5         swapped = false;
6         for (size_t i = 1; i < data.size(); ++i) {
7             if (data[i - 1] > data[i]) {
8                 swap(data[i - 1], data[i]);
9                 swapped = true;
10             }
11         }
12     } while (swapped);
13 }
14 
15 //Гарний приклад
16 void processVector(const vector<int>& data) {
17     vector<int> sortedData = data;
18     sort(sortedData.begin(), sortedData.end());
19 }
Обробка помилок
Код має бути надійним і передбачати можливі збої, оскільки програма має працювати стабільно навіть у разі помилок. 
Рекомендації:
Використовувати виключення (try/catch) для критичних помилок. Виключення дозволяють уникати аварійних завершень.
Зберігати інформацію про помилки для їх відстеження. Зрозуміла обробка помилок дозволяє швидше знаходити причину збоїв.
Приклад:
1 //Поганий приклад
2 int divideNumbers(int a, int b) {
3     return a / b;
4 }
5 
6 //Гарний приклад
7 int divideNumbers(int a, int b) {
8     if (b == 0) {
9         throw invalid_argument("Error: Division by zero");
10     }
11     return a / b;
12 }
13 
14 int main() {
15     try {
16         int result = divideNumbers(10, 0);
17     }
18     catch (const invalid_argument& e) {
19         cerr << "Caught exception: " << e.what() << endl;
20     }
21 }
Тестування та документування коду
Модульне тестування є фундаментальною практикою, яка дозволяє перевіряти роботу кожної окремої функції чи компонента системи. Важливо писати модульні тести для кожної функції, що допоможе виявляти потенційні помилки на ранніх стадіях розробки. 
Для полегшення процесу тестування рекомендується використовувати спеціалізовані бібліотеки, такі як Google Test. Ці інструменти надають потужні можливості для автоматизованої перевірки коректності роботи окремих модулів та функцій.
Не менш важливим є документування коду. Воно допомагає швидко зрозуміти призначення та принципи роботи того чи іншого компоненту системи.
Для ефективного документування рекомендується використовувати спеціалізовані інструменти, зокрема Doxygen. Такі інструменти дозволяють автоматично генерувати повноцінну технічну документацію безпосередньо з коментарів у вихідному коді.
При документуванні важливо чітко зазначати призначення кожної функції, описувати її параметри, можливі варіанти використання та особливості. Якісна документація полегшує роботу з кодом для всієї команди розробників.
Приклад:
1 /**
2  * @brief Клас калькулятора для базових математичних операцій
3  */
4 class Calculator {
5 public:
6     /**
7      * @brief Ділення двох чисел
8      * @param a Число, що ділиться
9      * @param b Число-дільник
10      * @return Результат ділення
11      * @throw invalid_argument Якщо відбувається ділення на нуль
12      */
13     double divide(double a, double b) {
14         if (b == 0) {
15             throw invalid_argument("Division by zero is prohibited");
16         }
17         return a / b;
18     }
19 };
20 
21 class CalculatorTest {
22 private:
23     Calculator calc;
24 
25     void testDivision() {
26         assert(calc.divide(6, 2) == 3.0);
27         assert(calc.divide(5, 2) == 2.5);
28 
29         try {
30             calc.divide(10, 0);
31             cout << "Error: Uncaught exception when dividing by zero" << endl;
32         }
33         catch (const invalid_argument& e) {
34             cout << "Exception successfully caught: " << e.what() << endl;
35         }
36     }
37 };
Список використаних джерел:
C++ Coding Standards: 101 Rules, Guidelines, and Best Practices URL: https://micro-os-plus.github.io/develop/sutter-101/
Google C++ Style Guide. URL: https://google.github.io/styleguide/cppguide.html
GoogleTest Primer. GoogleTest. URL: https://google.github.io/googletest/primer.html
C++ Core Guidelines. Error handling. URL: https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-errors
1.3 Висновок:
Дотримання запропонованих рекомендацій для оформлення коду на C++ значно покращує його якість та спрощує роботу з ним. Використання єдиного стилю форматування, чіткої структури та осмислених імен робить код легким для читання. Чітка структура проєкту, рефакторинг із дотриманням принципів і добре продумана обробка помилок полегшують внесення змін, виправлення багів і впровадження нових функцій. Наявність коментарів і документації, разом із використанням автоматизованого тестування, значно знижують ризик появи регресій і полегшують тестування нових змін.
Загалом, запропоновані правила та рекомендації створюють базу для розробки якісного, зрозумілого й ефективного коду, який легко підтримувати.
1.4 Посилання:
Посилання на GitHub репозиторій:
https://github.com/NureAfanasievaOksana/arkpz-pzpi-22-6-afanasieva-oksana/tree/main/Pract1
Посилання на YouTube відео з виступом:
https://youtu.be/du9otyDiP3Q
 
ДОДАТОК А
Слайди презентації
 
Рисунок А.1 – Титульний слайд
 
Рисунок А.2 – Зміст презентації
 
Рисунок А.3 – Вступ
 
Рисунок А.4 – Стильові рекомендації
 
Рисунок А.5 – Приклад коду до стильових рекомендацій
 
Рисунок А.6 – Правила найменування
 
Рисунок А.7 – Структура коду
 
Рисунок А.8 – Приклад коду дотримання структури коду
 
Рисунок А.9 – Коментарі
 
Рисунок А.10 – Принципи рефакторингу
 
Рисунок А.11 – Приклади коду використання принципів рефакторингу
 
Рисунок А.12 – Оптимізація продуктивності
 
Рисунок А.13 – Приклад коду оптимізації продуктивності
 
Рисунок А.14 – Обробка помилок
 
Рисунок А.15 – Тестування та документування коду
 
Рисунок А.16 – Приклад коду тестування
 
Рисунок А.17 – Приклад коду документування
 
Рисунок А.18 – Висновки
 
Рисунок А.19 – Список використаних джерел
 
Рисунок А.20 – Завершальний слайд
